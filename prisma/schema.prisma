generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum Role {
  SUPER_ADMIN
  OUTLET_ADMIN
  WORKER
  DRIVER
  CUSTOMER
}

enum EmployeeWorkShift {
  MORNING
  NOON
  NIGHT
}

enum EmploymentStatus {
  EMPLOYED
  PAUSED
  ENDED
}

enum WorkerStation {
  WASHING
  IRONING
  PACKING
}

enum PickupStatus {
  WAITING_FOR_DRIVER
  ON_THE_WAY_TO_CUSTOMER
  ON_THE_WAY_TO_OUTLET
  RECEIVED_BY_OUTLET
}

enum OrderStatus {
  // WAITING_FOR_PICKUP_DRIVER
  // ON_THE_WAY_TO_CUSTOMER
  // ON_THE_WAY_TO_OUTLET ga tau kira2 butuh atau ga
  ARRIVED_AT_OUTLET
  READY_FOR_WASHING
  BEING_WASHED
  WASHING_COMPLETED
  BEING_IRONED
  IRONING_COMPLETED
  BEING_PACKED
  AWAITING_PAYMENT
  READY_FOR_DELIVERY
  WAITING_FOR_DELIVERY_DRIVER
  BEING_DELIVERED_TO_CUSTOMER
  RECEIVED_BY_CUSTOMER
  COMPLETED
  CANCELLED_BY_CUSTOMER
  CANCELLED_BY_OUTLET
}

enum DeliveryStatus {
  NOT_READY_TO_DELIVER
  WAITING_FOR_DRIVER
  ON_THE_WAY_TO_OUTLET
  ON_THE_WAY_TO_CUSTOMER
  RECEIVED_BY_CUSTOMER
}

enum PaymentStatus {
  PENDING
  CANCELLED
  DENIED
  EXPIRED
  SUCCEEDED
}

enum ByPassStatus {
  ACCEPTED
  REJECTEED
}

enum AttendanceType {
  SIGN_IN
  SIGN_OUT
}

model User {
  id             Int       @id @default(autoincrement())
  fullName       String
  email          String    @unique
  password       String
  avatar         String    @default("https://res.cloudinary.com/dowc5iu9c/image/upload/v1735754490/avatar/default-avatar.png")
  isVerified     Boolean   @default(false)
  role           Role      @default(CUSTOMER)
  token          String?
  tokenExpiresIn DateTime?

  employee     Employee? // penanda employee atau bukan
  Address      Address[] // khusus customer
  Notification Notification[] // penampung notifikasi untuk semua role (customer dan employee)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}

model Employee {
  id        Int               @id @default(autoincrement())
  workShift EmployeeWorkShift
  station   WorkerStation?

  userId Int  @unique
  user   User @relation(fields: [userId], references: [id])

  Employment Employment[] // penampung data masa penugasan employee

  // daftar job employee
  PickupJob   PickupJob[]
  DeliveryJob DeliveryJob[]
  LaundryJob  LaundryJob[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}

model Employment {
  // perinci status kepegawaian employee, dia kerja di outlet mana, sejak kapan, sampai kapan. kenapa ada tabel ini karena mostly bakal kepake banget buat attendance
  // secara teknis bertindak sebagai jembatan relasi many-to-many employee dan outlet
  // (satu employee bisa terrelasi ke banyak outlet (contohnya history si employee pernah kerja di outlet mana aja tapi dalam satu waktu cuma bisa kerja di satu outlet) satu outlet bisa terrelasi ke banyak employee)
  id         Int      @id @default(autoincrement()) // ga dibikin composite key karena ada kemungkinan employee udah berenti kerja di satu outlet terus mulai kerja lagi di outlet yang sama
  employeeId Int
  employee   Employee @relation(fields: [employeeId], references: [id])
  outletId   Int
  outlet     Outlet   @relation(fields: [outletId], references: [id])

  employmentStatus EmploymentStatus @default(EMPLOYED)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}

model Address {
  // data address yang bisa dipake sebagai alamat customer atau alamat outlet
  id          Int     @id @default(autoincrement())
  isPrimary   Boolean @default(false)
  addressLine String
  province    String
  regency     String
  district    String
  village     String
  latitude    String
  longitude   String

  // nullable foreign key untuk relasi antara user (many-to-one) atau outlet (one-to-one). hanya bisa salah satu (user atau outlet)
  userId Int?
  user   User? @relation(fields: [userId], references: [id])

  Outlet Outlet?

  // daftar transport job yang pernah di-assign ke alamat ini
  PickupJob   PickupJob[]
  DeliveryJob DeliveryJob[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}

model Outlet {
  id         Int    @id @default(autoincrement())
  outletName String

  addressId Int     @unique
  address   Address @relation(fields: [addressId], references: [id])

  Employment Employment[] // daftar employee yang sedang dan pernah kerja di outlet
  PickupJob  PickupJob[] // secara teknis, daftar order yang sedang dan pernah dihandle sama outlet

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}

model PickupJob {
  // masih bingung apakah ini best practice apa ngga (insiasi order dari record pickupjob lalu dilanjut order terus delivery. alternatifnya ditampung semuanya (pickup-order-delivery) di satu tabel order gitu)
  id             Int          @id @default(autoincrement())
  pickupStatus   PickupStatus @default(WAITING_FOR_DRIVER)
  pickupDistance Int // bisa jadi jarak garis lurus atau jarak tempuh sepeda motor (ini bikin lebih jadi ribet). ngitungnya mestinya dihandle sama API geocoding
  pickupPrice    Int // pickupDistance dikali harga per satuan waktu jarak tempuh. variabel pengalinya belum tau best practicenya apakah perlu disimpan agar dinamis atau cukup nanti ditulis di controller aja

  costumerAddressId Int
  costumerAddress   Address @relation(fields: [costumerAddressId], references: [id]) // data alamat pickup customer data siapa customer yang order juga diambil dari sini. relationship many-to-one

  outletId Int
  outlet   Outlet @relation(fields: [outletId], references: [id]) // data outlet yang diassign buat ngerjain laundry. data alamat outlet diambil dari sini. relasi many-to-one

  driverId Int?
  driver   Employee? @relation(fields: [driverId], references: [id]) // data driver yang akan handle job. nullable karena pas data ke-create, ada jeda buat cari driver dulu. relasi many-to-one

  Order Order? // *???one-to-one atau one-to-many (sekarang one-to-one)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}

model Order {
  // masih bingung apakah ini best practice apa ngga (insiasi order dari record pickupjob lalu dilanjut order terus delivery. alternatifnya ditampung semuanya (pickup-order-delivery) di satu tabel order gitu)
  id                Int         @id @default(autoincrement())
  orderStatus       OrderStatus @default(ARRIVED_AT_OUTLET)
  weight            Int
  isPaid            Boolean     @default(false) // indikator untuk sudah boleh lanjut delivery atau ga
  totalLaundryPrice Int // sum harga orderItem di order ini (qty dikali laundryPrice dari loundryItemnya punya orderItem) ditambah weight dikali harga per satuan berat (belum termasuk ongkir)

  pickupId Int       @unique
  pickup   PickupJob @relation(fields: [pickupId], references: [id]) // *???one-to-one atau one-to-many (sekarang one-to-one)

  OrderItem   OrderItem[] // daftar pakaian dan kuantitasnya
  LaundryJob  LaundryJob[] // isinya bakal ada 3 job: wash, iron, pack
  DeliveryJob DeliveryJob? // *???one-to-one atau one-to-many (sekarang one-to-one)
  Payment     Payment? // *???one-to-one atau one-to-many (sekarang one-to-one) kalo one-to-many bisa handle banyak payment antisipasi kalau payment si customernya gagal

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}

model OrderItem {
  id  Int @id @default(autoincrement())
  qty Int

  orderId Int
  order   Order @relation(fields: [orderId], references: [id])

  laundryItemId Int
  laundryItem   LaundryItem @relation(fields: [laundryItemId], references: [id])

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}

model LaundryItem {
  // daftar jenis pakaian yang eligible buat dicuci dengan jasa app ini. superadmin punya hak buat create, edit atau delete
  id           Int    @id @default(autoincrement())
  itemName     String
  laundryPrice Int // ini masih belum tau apakah perlu atau tidak. kalau ada ini memberi kebebasan si superadmin buat narifin harga tambahan untuk jenis cucian tertentu. kekurangannya harganya jadi sama buat semua outlet

  OrderItem OrderItem[]

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}

model LaundryJob {
  id                Int           @id @default(autoincrement())
  station           WorkerStation
  isByPassRequested Boolean       @default(false) // penunjuk bahwa si worker request bypass atau ga. masih belum tau apakah worker mampu untuk bikin banyak bypass request dalam satu job atau cuma sekali aja. kalo sekali aja jadinya kayak gini 
  isCompleted       Boolean       @default(false)
  byPassNote        String?
  byPassStatus      ByPassStatus?

  orderId Int
  order   Order @relation(fields: [orderId], references: [id])

  workerId Int
  worker   Employee @relation(fields: [workerId], references: [id])

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}

model DeliveryJob {
  // masih bingung apakah ini best practice apa ngga (insiasi order dari record pickupjob lalu dilanjut order terus delivery. alternatifnya ditampung semuanya (pickup-order-delivery) di satu tabel order gitu)
  id               Int            @id @default(autoincrement())
  deliveryStatus   DeliveryStatus @default(NOT_READY_TO_DELIVER)
  deliveryDistance Int // bisa jadi jarak garis lurus atau jarak tempuh sepeda motor (ini bikin lebih jadi ribet). ngitungnya mestinya dihandle sama API geocoding
  deliveryPrice    Int // deliveryDistance dikali harga per satuan waktu jarak tempuh. variabel pengalinya belum tau best practicenya apakah perlu disimpan agar dinamis atau cukup nanti ditulis di controller aja

  costumerAddressId Int
  costumerAddress   Address @relation(fields: [costumerAddressId], references: [id]) // kolom ini diadain lagi karena urang (fauzi) kepikiran ngasih fitur buat si customer bisa ngatur alamat pickup sama alamat deliverynya beda (tapi dua-duanya alamatnya mesti punya customer itu juga). ga wajib. bisa diilangin. kalo diilangin berarti alamat pickup sama delivery sama, terus nanti alamat deliverynya diambil dari data pickupJob. relasi many-to-one

  orderId Int   @unique
  order   Order @relation(fields: [orderId], references: [id]) // *???one-to-one atau one-to-many (sekarang one-to-one)

  driverId Int?
  driver   Employee? @relation(fields: [driverId], references: [id])

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}

model Notification {
  id          Int     @id @default(autoincrement())
  isRead      Boolean @default(false) // buat indikator notifikasi baru sama notifikasi lama (entar beda styling yang baru sama yang lamanya)
  title       String
  description String

  userId Int
  user   User @relation(fields: [userId], references: [id])

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}

model Payment {
  // kurleb sama seperti payment minpro, pake midtrans, ini ke-create bersamaan ketika ordernya ke-create
  id              Int           @id @default(autoincrement())
  totalPrice      Int // ini sum totalLaundryPrice, pickupPrice dan deliveryPrice
  paymentStatus   PaymentStatus @default(PENDING)
  paymentMethod   String?
  snapToken       String?
  snapRedirectURL String?

  orderId Int   @unique
  order   Order @relation(fields: [orderId], references: [id]) // *???one-to-one atau one-to-many (sekarang one-to-one)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}

model EmployeeAttendance {
  // data absensi harian
  id             Int            @id @default(autoincrement())
  attendanceType AttendanceType

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
}
